+ Feature name: `bee-hash`
+ Start date: 2019-10-15
+ RFC PR: [iotaledger/bee-rfcs#0000](https://github.com/iotaledger/bee-rfcs/pull/0000)
+ Bee issue: [iotaledger/bee#0000](https://github.com/iotaledger/bee/issues/0000)

# Summary

This RFC proposes the implementation of the cryptographic hash functions `CurlP` and `Kerl`. `CurlP81`, a newtype for
`CurlP` with 81 rounds, and `Kerl` are the two cryptographic hash functions used by `iri v1.8.1`, the IOTA reference
implementation. Both are sponge constructions, and thus follow a very similar structure.

In `iri v1.8.1`, `CurlP81` is used for generating transaction hashes and --- through the `PearlDiver` algorithm --- for
proof of work calculations. `Kerl` on the other hand is used as part of all other operations requiring cryptographic
security, namely address generation, signature generation and verification, and bundle hash calculation.

Useful links:

+ [The sponge and duplex constructions](https://keccak.team/sponge_duplex.html)
+ [Curl-p](...)
+ [Kerl specification](https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md)
+ [Troika specification](https://www.cyber-crypt.com/troika/)
+ [PearlDiver](...)
+ [`iri v1.8.1`](...)

# Motivation

One goal of the `bee` project is to make it possible to write nodes that are able to run on the current main net of
IOTA. Nodes comprising the current main net are either implemented using the IOTA reference implementation, version `iri
v1.8.1`, or using libraries compatible with it.

In order to participate in the IOTA network, a node needs be able to construct valid messages that can be verified by
other nodes in the network. Conversely, a node needs to be able to verify other nodes' messages. IOTA messages are
called *bundles* and consist of one or more *transactions*. A transaction is a fixed-size binary object that itself is
partitioned into several fixed-size fields. A *valid* transaction then is a transaction with fields containing correctly
calculated hashes, signatures, and nonce values. For an overview of the different fields of a transaction, see the
documents on [IOTA transactions and bundle].

For example, a transaction that withdraws funds from an IOTA address needs to have the following set correctly:

<!-- TODO: go into a bit more detail how and which hashes are used below -->

- signature
- address
- bundle hash
- transaction hash
- nonce

The cryptographic hash functions used in `iri v1.8.1` are `Curl-P-81` and `Kerl`, which are both sponge constructions.
A simplistic (and not at all complete) summary is that these are functions that are equipped with a memory state and a
function that replaces the state memory using some input string (which can be the state memory itself). A portion of the
memory state is then the output. In the sponge metaphor, the process of replacing the memory state by an input string is
said to *absorb* the input, while the process of producing an output is said to *squeeze out* an output.

This RFC hence proposes to implement the `Curl` and `Kerl` sponge structures, with both being implement using the same
or very similar function signatures. The shared interface is thus defined by convention, and there is no unifying
`Sponge` trait.

The hashes are expected to be used like this:

```rust
// Create a Curl instance with 81 rounds.
// This is equivalent to calling `Curl::new(81)`.
let mut curl = Curl::default();

// Assume this is a transaction and we want to digest a hash.
let transaction = [0i8; 8019];
let mut tx_hash = [0i8; 243];

// Absorb the transaction.
curl.absorb(&transaction);
// And squeeze into the `tx_hash` buffer.
curl.squeeze_into(&mut tx_hash);
```

```rust
// Create a default Kerl instance. Kerl does not come with a configurable number of rounds, so that
// `Kerl::new()` and `Kerl::default()` yield the same result.
let mut kerl = Kerl::default();

// `Kerl::digest` is a function that combines `Kerl::absorb` and `Kerl::squeeze`. `Kerl::digest_into`
// combines `Kerl::absorb` with `Kerl::squeeze_into`. `Curl` provides the same methods.
let tx_hash = kerl.digest(&transaction);
```

Useful links:

- [IOTA transactions and bundle](https://docs.iota.org/docs/dev-essentials/0.1/concepts/bundles-and-transactions)

# Detailed design

This structure design is going to be the interface of any sponge function. Users can expect each hash instance would
provide at least these public methods. Imagine it's like a real sponge, it `absorb`s the clone of input reference
provided by users. And they don't need to know how internal permutation and transformation work, just `squeeze` the
sponge and there will be a mutable reference as output. The internal state will not be cleared unless `reset` is called. 

```rust
#[derive(Clone, Copy)]
pub struct Curl {
    rounds: usize,
    state: [Trit; STATE_LENGTH],
}

impl Default for Curl {
    fn default() -> Curl {
        Curl {
            rounds: 81,
            state: [0; STATE_LENGTH],
        }
    }
}
```

As defined above, a `Sponge` instance, take `Curl` for example, should be defined as a structure like this. What fields
should have depend on each implementation. In this simple `Curl` strucutre, we just need a memory state and how many
round should take. `Default` trait is set because we only uses 81 rounds at the moment. While `Sponge` trait doesn't
care about thread safety and other concerns, we leave each type to decide which traits should also be included during
implementation. The outcome should look like this:

```rust

impl Curl {

    /// Absorb trits into the sponge
    pub fn absorb(&mut self, input: &[Trit]) {
        for c in input.chunks(HASH_LENGTH) {
            self.state[0..c.len()].copy_from_slice(c);
            self.transform();
        }
    }

    /// Squeeze trits out of the sponge and copy them into `out`
    pub fn squeeze(&mut self, output: &mut [Trit]) {
        let trit_count = output.len();
        let hash_count = trit_count / HASH_LENGTH;

        for i in 0..hash_count {
            output[i * HASH_LENGTH..(i + 1) * HASH_LENGTH]
                .copy_from_slice(&self.state[0..HASH_LENGTH]);
            self.transform();
        }

        let last = trit_count - hash_count * HASH_LENGTH;
        output[trit_count - last..].copy_from_slice(&self.state[0..last]);
        if trit_count % HASH_LENGTH != 0 {
            self.transform();
        }
    }

    /// Reset the sponge to initial state
    pub fn reset(&mut self) {
        self.state = [0; STATE_SIZE];
    }

    /// Digest inputs and then compute the hash with length of provided output slice
    pub fn digest (&mut self, input: &[Trit], output: &mut [Trit]) {
        self.absorb(input);
        self.squeeze(output);
    }

    // Once general methods are defined, every types can implement any methods they want.
    pub fn new(rounds: usize) -> Curl {
        let mut curl = Curl::default();
        curl.rounds = rounds;
        curl
    }

    pub fn state(&self) -> &[Trit] {
        &self.state
    }

    fn transform(&mut self) {
        let mut local_state: [Trit; STATE_LENGTH] = [0; STATE_LENGTH];

        for round in 0..self.rounds {
            let (state_out, state) = if round % 2 == 0 {
                (&mut local_state, &self.state)
            } else {
                (&mut self.state, &local_state)
            };

            for state_index in 0..STATE_LENGTH {
                let idx: usize = (state[TRANSFORM_INDICES[state_index]] as usize)
                    .wrapping_add((state[TRANSFORM_INDICES[state_index + 1]] as usize) << 2)
                    .wrapping_add(5);

                state_out[state_index] = TRUTH_TABLE[idx];
            }
        }
    }
}

```

While this showcase should work, there might be more specific sponge type or even different hash algorithm suit for
different use case.  The types in its fields and method signature by then may look different. No matter how each sponge
type is implement, they should all provide public methods we mentioned above at least. Here is another example how
`Kerl` should be implemented in similar manner:

```rust
#[derive(Clone, Copy)]
// Kerl is wrapper for Keccak to hash ternary inputs
pub struct Kerl(Keccak);

impl Default for Kerl {
    fn default() -> Kerl {
        Kerl(Keccak::new_keccak384())
    }
}

impl Kerl {
    pub fn absorb(&mut self, trits: &[Trit]) {
        assert_eq!(trits.len() % TRIT_LENGTH, 0);
        let mut bytes: [u8; BYTE_LENGTH] = [0; BYTE_LENGTH];

        for chunk in trits.chunks(TRIT_LENGTH) {
            trits_to_bytes(chunk, &mut bytes);
            self.0.update(&bytes);
        }
    }

    pub fn squeeze(&mut self, out: &mut [Trit]) {
        assert_eq!(out.len() % TRIT_LENGTH, 0);
        let mut bytes: [u8; BYTE_LENGTH] = [0; BYTE_LENGTH];

        for chunk in out.chunks_mut(TRIT_LENGTH) {
            self.0.pad();
            self.0.fill_block();
            self.0.squeeze(&mut bytes);
            self.reset();
            bytes_to_trits(&mut bytes.to_vec(), chunk);
            for b in bytes.iter_mut() {
                *b = *b ^ 0xFF;
            }
            self.0.update(&bytes);
        }
    }

    pub fn reset(&mut self) {
        self.0 = Keccak::new_keccak384();
    }

    pub fn digest (&mut self, input: &[Trit], output: &mut [Trit]) {
        self.absorb(input);
        self.squeeze(output);
    }

    // ...Other public and private methods
}
```

 In summary, each sponge type must provide following public methods with similar signature:

- `fn absorb(&mut self, input: &[Trit])`;
- `fn squeeze(&mut self, output: &mut [Trit])`;
- `fn reset(&mut self)`;
- `fn digest (&mut self, input: &[Trit], output: &mut [Trit])`

# Drawbacks

- While users can use each types and methods directly, some might want to implement with some traits to benefit from
  trait object and trait bound.
- Type defined like this doesn't completely decouple implementation between layers. It just provides a common interface.
- This type only suit for sponge functions and also focus on ternary system. It might not be compatible to other binary
  cryptography in some edge case.

# Rationale and alternatives

+ `Curl` and `Kerl` are fundamental to the `iri v1.8.1` main net. They are thus essential for compatibility with it.
+ It is not clear if a `Sponge` trait as a unifying interface would find use. The similar interfaces between `Curl`
  and `Kerl` are thus defined by convention.
+ This type is idiomatic in Rust. Users are not required to know the implement details of each hash algorithm.
- We still have option to just use `Digest` crate, but it's parameters are all type of `u8`. IOTA use trits as basic
  type which means this library may not fit our need. The ecosystem of this crate is also not fully mature yet. It may
be a burden to add another dependency.
- Crypto community in Rust usually don't rely on native crates written all in Rust. Like
  [sodiumoxide](https://github.com/sodiumoxide/sodiumoxide) is a Rust binding to
[libsodium](https://github.com/jedisct1/libsodium). There's also [ring](https://github.com/briansmith/ring) in a hybrid
of Rust, C, and assembly language which also expose a Rust API. However, utilize libraries like these will also need to
take care of different language bindings and their foreign function interface. There will be unsafe scenarios have to
consider more over. It will be better for us to stick with full Rust at the moment. In deed there's RustCrypto community
provides various crates and utilities like `Digest`. But like it states above, the ecosystem is not truly mature yet. As
this more low-level concern, we should make less dependency as possible.

# Unresolved questions

- Parameters are slice reference in both input and output. Do we want to consume value or create a new instance as
  return values?
- Should we have low level traits defined like Digest? If so, should we also provide macro to implement these traits
  easily?
- Implementation of each hash functions and other utilities like HMAC should have separate RFCs for them.
- Decision on implementation of `Troika` is still unknown.
