+ Feature name: `bee-hash`
+ Start date: 2019-10-15
+ RFC PR: [iotaledger/bee-rfcs#0000](https://github.com/iotaledger/bee-rfcs/pull/0000)
+ Bee issue: [iotaledger/bee#0000](https://github.com/iotaledger/bee/issues/0000)

# Summary

This RFC proposes the implementation of the cryptographic hash functions `Curl-P-81` and `Kerl`, and a unifying `Sponge`
trait. `Curl-P-81` and `Kerl` are the two cryptographic hash functions used by `iri v1.8.1`, the IOTA reference
implementation. As both are sponge constructions, they share a similar structure amenable to abstraction.

In `iri v1.8.1`, `Curl-P-81` is used for generating transaction hashes, and as the cryptographic hash function in
`PearlDiver`, its proof of work algorithm. `Kerl` on the other hand is used as part of all other operations requiring
cryptographic security, namely address generation, signature generation and verification, and bundle hash calculation.

Useful links:

+ [The sponge and duplex constructions](https://keccak.team/sponge_duplex.html)
+ [Curl-p](...)
+ [Kerl specification](https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md)
+ [Troika specification](https://www.cyber-crypt.com/troika/)
+ [PearlDiver](...)
+ [`iri v1.8.1`](...)


# Motivation

One goal of the `bee` project is to make it possible to write nodes that are able to run on the current main net of
IOTA. Nodes comprising the current main net are implemented using the IOTA reference implementation, version `iri
v1.8.1`, or using libraries compatible with it.

In order to participate in the IOTA network, a node needs be able to construct valid messages that can be verified by
other nodes in the network. Conversely, a node needs to be able to verify other nodes' messages. IOTA messages are
called *bundles* and consist of one or more *transactions*. A transaction is a fixed-size binary object that itself is
partitioned into several fixed-size fields. A *valid* transaction then is a transaction with fields containing correctly
calculated hashes, signatures, and nonce values. For an overview of the different fields of a transaction, see the
documents on [IOTA transactions and bundle].

For example, a transaction that withdraws funds from an IOTA address needs to have the following set correctly:

<!-- TODO: go into a bit more detail how and which hashes are used below -->

+ signature
+ address
+ bundle hash
+ transaction hash
+ nonce

The cryptographic hash functions used in `iri v1.8.1` are `Curl-P-81` and `Kerl`, which are both sponge constructions.
A simplistic (and not at all complete) summary is that these are functions that are equipped with a memory state and
a function that replaces the state memory using some input string (which can be the state memory itself). A portion of
the memory state is then the output. In the sponge metaphor, the process of replacing the memory state by an input
string is said to *absorb* the input, while the process of producing an output is said to *squeeze out* an output.

This RFC hence proposes to implement the `Curl-P-81` and `Kerl` sponges, together with a unifying `Sponge` trait. These
are expected to be used like this:

```rust
// Create a Curl instance with default rounds number which is 81.
let mut curl = Curl::default();
// Assume this is a transaction and we want to digest a hash.
let transaction = [0i8; 8019];
let mut tx_hash = [0i8; 243];

// `digest` is a provided method of Sponge which can separate with `absorb` & `squeeze` alternatively.
// curl.absorb(&transaction);
// curl.squeeze(&mut tx_hash);
curl.digest(&transaction, &mut tx_hash);

// That said we have `Kerl` and would like to hash with this instead.
let mut kerl = Kerl::default();

// Same trait methods are called and signatures are not changed. Separate methods are still available.
// kerl.absorb(&transaction);
// kerl.squeeze(&mut tx_hash);
kerl.digest(&transaction, &mut tx_hash);
```

Useful links:

+ [IOTA transactions and bundle](https://docs.iota.org/docs/dev-essentials/0.1/concepts/bundles-and-transactions)

# Detailed design

This trait is going to be the interface of any sponge function. Imagine it's like a real sponge, it `absorb`s the
clone of input reference provided by users. And they don't need to know how internal permutation and transformation
work, just `squeeze` the sponge and there will be a mutable reference as output. The internal state will not be cleared
unless `reset` is called.

```rust 
pub trait Sponge
where
    Self: Default + Clone,
{
    type Item;

    /// Absorb trits into the sponge
    fn absorb(&mut self, input: &[Self::Item]);
    
    /// Squeeze trits out of the sponge and copy them into `out`
    fn squeeze(&mut self, output: &mut [Self::Item]);

    /// Reset the sponge to initial state
    fn reset(&mut self);

    /// Digest inputs and then compute the hash with length of provided output slice
    fn digest (&mut self, input: &[Self::Item], output: &mut [Self::Item]) {
        self.absorb(input);
        self.squeeze(output);
    }
}

```

As defined above, `Sponge` trait requires the type has trait bound of `Default` and `Clone` trait. iSince it doesn't
contain any instance creation method, we require the type should at least have `Default` trait and any other method like
`new` is optional in hope of giving flexibility. While `Sponge` trait doesn't care about thread safety and other
concerns, we leave each type to decide which traits should also be included during implementation. Also note that
default associated type isn't provided since it's still unstable feature for a long time. Consider our common crates
should be compatible to stable, it should specify the type when implementing trait. The outcome should look like this:

```rust
impl Sponge for Curl
where
    Self: Send + 'static,
{
    type Item = Trit;

    fn absorb(&mut self, input: &[Self::Item]) {
        for c in input.chunks(HASH_LENGTH) {
            self.state[0..c.len()].copy_from_slice(c);
            self.transform();
        }
    }

    fn squeeze(&mut self, output: &mut [Self::Item]) {
        let trit_count = output.len();
        let hash_count = trit_count / HASH_LENGTH;

        for i in 0..hash_count {
            output[i * HASH_LENGTH..(i + 1) * HASH_LENGTH]
                .copy_from_slice(&self.state[0..HASH_LENGTH]);
            self.transform();
        }

        let last = trit_count - hash_count * HASH_LENGTH;
        output[trit_count - last..].copy_from_slice(&self.state[0..last]);
        if trit_count % HASH_LENGTH != 0 {
            self.transform();
        }
    }

    fn reset(&mut self) {
        self.state = [0; STATE_SIZE];
    }
}

```

With these trait and type all being defined, top layer modules are able to call them not only via their instance create
methods directly but also with trait bound. While users can just call the required and provided methods like
[Motivation](#Motivation) mentioned, we expect upper layer might want to be loosely coupled from actual hash algorithm.
This is where trait bound can bring advantages. A signature for instance can just call trait methods without worrying
its internal details:

```rust
impl Transaction {
    pub fn sign<S: Sponge>(hasher: S) {
        unimplemented!()
    }
}
```

# Drawbacks

- Users may just want to use each function directly without methods of this trait.
- This trait doesn't completely decouple implementation between layers. It just provides a common interface.
- This trait only suit for sponge functions and also focus on ternary system. It might not be compatible to other binary
	cryptography.
- There is a sponge-less curl implementation optimized for performing proof of work. It might not be benefited from this
	trait.

# Rationale and alternatives

- `Sponge` trait provide a common interface suit for any type of sponge functions.
- This trait is idiomatic in Rust. Users are not required to know the implement details of each hash algorithm.
- We still have option to just use `Digest` crate, but it's parameters are all type of `u8`. IOTA use trits as basic
	type which means this library may not fit our need. The ecosystem of this crate is also not fully mature yet. It may
	be a burden to add another dependency.
- Crypto community in Rust usually don't rely on native crates written all in Rust. Like
	[sodiumoxide](https://github.com/sodiumoxide/sodiumoxide) is a Rust binding to
	[libsodium](https://github.com/jedisct1/libsodium). There's also [ring](https://github.com/briansmith/ring) in a
	hybrid of Rust, C, and assembly language which also expose a Rust API. However, utilize libraries like these will also
	need to take care of different language bindings and their foreign function interface. There will be unsafe scenarios
	have to consider more over. It will be better for us to stick with full Rust at the moment. In deed there's RustCrypto
	community provides various crates and utilities like `Digest`. But like it states above, the ecosystem is not truly
	mature yet. As this more low-level concern, we should make less dependency as possible.

## Future work

+ Troika

# Unresolved questions

- Parameters are slice reference in both input and output. Do we want to consume value or create a new instance as
	return values?
- Should we have low level traits defined like Digest? If so, should we also provide macro to implement these traits
	easily?
- Implementation of each hash functions and other utilities like HMAC should have separate RFCs for them.
