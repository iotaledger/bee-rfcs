<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0041-shutdown - The Bee RFC Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0030-protocol-messages.html">0030-protocol-messages</a></li><li class="chapter-item expanded "><a href="0031-configuration.html">0031-configuration</a></li><li class="chapter-item expanded "><a href="0033-network.html">0033-network</a></li><li class="chapter-item expanded "><a href="0034-ternary-hash.html">0034-ternary-hash</a></li><li class="chapter-item expanded "><a href="0035-logging.html">0035-logging</a></li><li class="chapter-item expanded "><a href="0036-ternary.html">0036-ternary</a></li><li class="chapter-item expanded "><a href="0037-ternary-numeric-conversion.html">0037-ternary-numeric-conversion</a></li><li class="chapter-item expanded "><a href="0041-shutdown.html" class="active">0041-shutdown</a></li><li class="chapter-item expanded "><a href="0042-secret-debug-display.html">0042-secret-debug-display</a></li><li class="chapter-item expanded "><a href="0044-secret-zeroize-drop.html">0044-secret-zeroize-drop</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Bee RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>Feature name: <code>shutdown</code></li>
<li>Start date: 2020-07-03</li>
<li>RFC PR: <a href="https://github.com/iotaledger/bee-rfcs/pull/41">iotaledger/bee-rfcs#41</a></li>
<li>Bee issue: <a href="https://github.com/iotaledger/bee/issues/96">iotaledger/bee#96</a></li>
</ul>
<h1><a class="header" href="#summary" id="summary">Summary</a></h1>
<p>This RFC proposes a unified way of achieving a graceful shutdown of arbitrarily many async workers and their utilized resources in the Bee framework.</p>
<h1><a class="header" href="#motivation" id="motivation">Motivation</a></h1>
<p>Rust provides one of the most powerful, performant, and still safest abstractions to deal with <em>concurrency</em>. You can read about Rust's concurrency story <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">here</a>.</p>
<p>One problem that arises when dealing with many asynchronous tasks within a system is to ensure that all of them terminate gracefully once an agreed upon shutdown signal was issued. An example for this is when a software intercepts the press of <code>^C</code> in the terminal, and then executes specialized instructions to prevent data corruption before finally exiting the application.</p>
<p>This feature solves this problem by introducing a type called <code>Shutdown</code>, that allows to register ansynchronous workers, and <code>execute</code> a shutdown in a 3-step process:</p>
<ol>
<li>Send a shutdown signal to all registered workers;</li>
<li>Wait for all the workers to terminate;</li>
<li>Perform final actions (like flushing buffers to databases, saving files, etc.)</li>
</ol>
<h1><a class="header" href="#detailed-design" id="detailed-design">Detailed design</a></h1>
<p>As the shutdown signal itself contains no data, the zero-sized unit type <code>()</code> is used to model it. Furthermore, as the synchronizing mechanism, this RFC proposes the use of <code>oneshot</code> channels from the <code>futures</code> crate. Those channels are consumed, i.e. destroyed, when calling <code>send</code> once; this way Rust ensures at compile-time, that no further redundant shutdown signals can be sent to the same listener.</p>
<p>To make the code more readable and less verbose, this RFC proposes the following type aliases:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The &quot;notifier&quot; is the origin of the shutdown signal. For each spawned worker a
// dedicated notifier will be created and kept in a list.
type ShutdownNotifier = oneshot::Sender&lt;()&gt;;

// The &quot;listener&quot; is the receiver of the shutdown signal. It awaits the shutdown
// signal as part of the event loop of the corresponding worker.
type ShutdownListener = oneshot::Receiver&lt;()&gt;;

// For each async worker the async runtime creates a `Future`, that completes when the
// worker terminates, i.e. shuts down. To make sure, the shutdown is complete, one has
// to store those `Future`s in a list, and await all of them iteratively before exiting
// the program.
type WorkerShutdown = Box&lt;dyn Future&lt;Output = Result&lt;(), WorkerError&gt;&gt; + Unpin&gt;;

// Before shutting down a system, workers oftentimes need to perform one or more final
// actions to prevent data loss and/or data corruption. Therefore each worker can register
// an arbitrary amount of actions, that will be executed as the final step of the shutdown
// process.
type Action = Box&lt;dyn FnOnce()&gt;;
<span class="boring">}
</span></code></pre></pre>
<p><strong>NOTE:</strong> <code>WorkerShutdown</code> and <code>Action</code> are boxed trait objects; hence have a single owner, and are stored on the heap. The <code>Unpin</code> marker trait requirement ensures that the given trait object can be moved into the internal datastructure. If the worker terminates with an error, it will be wrapped by a variant of the <code>WorkerError</code> enum. If the worker terminates without any error, <code>()</code> is returned - this time indicating that the worker doesn't produce a return value.</p>
<h2><a class="header" href="#shutdown" id="shutdown"><code>Shutdown</code></a></h2>
<p>The shutdown functionality can be implemented using only one central type, that essentially is an append-only registry with a single <code>execute</code> operation. There is no need for removal, or identifying single items as the operation is applied to all of them equally, and once done, the whole program can be expected to terminate.</p>
<p>This <code>Shutdown</code> type looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Shutdown {
    // A list of all registered shutdown signal senders, briefly labeled as &quot;notifiers&quot;.
    notifiers: Vec&lt;ShutdownNotifier&gt;,

    // A list of all registered worker termination `Future`s.
    worker_shutdowns: Vec&lt;WorkerShutdown&gt;,

    // A list of all registered finalizing actions performed once all async workers
    // have terminated.
    actions: Vec&lt;Action&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The API of <code>Shutdown</code> is very small. It only needs to allow filling those internal lists, and provide an <code>execute</code> method to facilitate the actual shutdown:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Shutdown {

    // Creates a new instance
    fn new() -&gt; Self {
        Self::default()
    }

    // Registers a worker shutdown future, which completes once the worker terminates in one
    // way or another, and registers a shutdown notification channel by providing its sender half.
    fn add_worker_shutdown(
        &amp;mut self,
        notifier: ShutdownNotifier,
        worker: impl Future&lt;Output = Result&lt;(), WorkerError&gt;&gt; + Unpin + 'static,
    ) {
        self.notifiers.push(notifier);
        self.worker_shutdowns.push(Box::new(worker));
    }

    // Registers an action to perform when the shutdown is executed.
    fn add_action(&amp;mut self, action: impl FnOnce() + 'static) {
        self.actions.push(Box::new(action));
    }

    // Executes the shutdown.
    async fn execute(mut self) -&gt; Result&lt;(), Error&gt; {
        // Step 1: notify all registrees.
        while let Some(notifier) = self.notifiers.pop() {
            notifier.send(()).map_err(|_| Error::SendingShutdownSignalFailed)?
        }

        // Step 2: await workers to terminate their event loop.
        while let Some(worker_shutdown) = self.worker_shutdowns.pop() {
            if let Err(e) = worker_shutdown.await {
                error!(&quot;Awaiting worker failed: {:?}.&quot;, e);
            }
        }

        // Step 3: perform finalizing actions to prevent data/resource corruption.
        while let Some(action) = self.actions.pop() {
            action();
        }

        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>About the <code>execute</code> method there are three things worth mentioning:</p>
<ol>
<li>takes <code>self</code> by value - in other words - claims ownership over the <code>Shutdown</code> instance, which means that it will be deallocated at the end of the method body, and can no longer be used;</li>
<li>is decorated with the <code>async</code> keyword, which means that under the hood it returns a <code>Future</code> that needs to be polled by an async runtime in order to make progress. In this specific case of a shutdown it almost always makes sense to <code>block_on</code> this method;</li>
<li>workers shut down in reverse order as they registered;</li>
</ol>
<h1><a class="header" href="#drawbacks" id="drawbacks">Drawbacks</a></h1>
<ul>
<li>No known drawbacks; the proposal uses trait objects, that have a certain performance overhead, but this shutdown is a one-time operation, performance is not a major issue;</li>
</ul>
<h1><a class="header" href="#rationale-and-alternatives" id="rationale-and-alternatives">Rationale and Alternatives</a></h1>
<ul>
<li>No viable alternatives known to the author;</li>
</ul>
<h1><a class="header" href="#unresolved-questions" id="unresolved-questions">Unresolved questions</a></h1>
<ul>
<li>Should we have a forced shutdown after a certain time interval, in case some worker fails to terminate? When would such a thing actually happen?</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="0037-ternary-numeric-conversion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="0042-secret-debug-display.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="0037-ternary-numeric-conversion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="0042-secret-debug-display.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
